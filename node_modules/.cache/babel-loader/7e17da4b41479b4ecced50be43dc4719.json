{"ast":null,"code":"var _jsxFileName = \"D:\\\\CSE499B\\\\visualize-algo\\\\src\\\\components\\\\algorithms\\\\MergeSort.js\";\nimport React from 'react';\nimport { newTrace, addToTrace, createKey } from './helpers';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst MergeSort = nums => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function merge(original, start, mid, end) {\n    const left = original.slice(start, mid);\n    const right = original.slice(mid, end);\n    let i = 0;\n    let j = 0;\n    let k = 0;\n\n    while (i < left.length && j < right.length) {\n      if (left[i] <= right[j]) {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = left[i];\n        i++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      } else {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = right[j];\n        j++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      }\n\n      k++;\n    }\n\n    while (i < left.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = left[i];\n      i++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    while (j < right.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = right[j];\n      j++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    left.length = 0;\n    right.length = 0;\n  }\n\n  function recursiveMergeSort(original, start, end) {\n    const length = end - start;\n\n    if (length < 2) {\n      // original = []\n      if (length < 1) return original; // original = [x]\n      else return [original[start]];\n    }\n\n    const midPoint = Math.floor((start + end) / 2); // Visualize: First Half\n\n    addToTrace(trace, original, [], [...Array(midPoint - start).keys()].map(i => i + start));\n    recursiveMergeSort(original, start, midPoint); // Visualize: Second Half\n\n    addToTrace(trace, original, [], [...Array(end - midPoint).keys()].map(i => i + midPoint));\n    recursiveMergeSort(original, midPoint, end);\n    merge(original, start, midPoint, end);\n  }\n\n  recursiveMergeSort(nums, 0, nums.length); // Visualize: Mark all elements as sorted\n\n  addToTrace(trace, nums, [...Array(nums.length).keys()]);\n  return trace;\n};\n\n_c = MergeSort;\nexport const MergeSortKey = createKey('Call Merge Sort', null, 'Overwrite from axillary array');\nexport const MergeSortP = {\n  l0: /*#__PURE__*/_jsxDEV(\"span\", {\n    Style: \"margin: 0px\",\n    children: /*#__PURE__*/_jsxDEV(\"line\", {\n      children: \" split each element into partitions of size 1\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 35\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 95,\n    columnNumber: 9\n  }, this),\n  l1: /*#__PURE__*/_jsxDEV(\"span\", {\n    Style: \"margin: 15px\",\n    children: /*#__PURE__*/_jsxDEV(\"line\", {\n      children: \"recursively merge adjacent partitions \"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 97,\n      columnNumber: 37\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 97,\n    columnNumber: 10\n  }, this),\n  l2: /*#__PURE__*/_jsxDEV(\"span\", {\n    Style: \"margin: 25px\",\n    children: /*#__PURE__*/_jsxDEV(\"line\", {\n      children: [\"  for i = leftelementId to rightelementId \", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 99,\n        columnNumber: 54\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 99,\n      columnNumber: 5\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 98,\n    columnNumber: 9\n  }, this),\n  l3: /*#__PURE__*/_jsxDEV(\"span\", {\n    Style: \"margin: 35px\",\n    children: /*#__PURE__*/_jsxDEV(\"line\", {\n      children: \"if leftPartHeadValue <= rightPartHeadValue\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 101,\n      columnNumber: 36\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 101,\n    columnNumber: 9\n  }, this),\n  l4: /*#__PURE__*/_jsxDEV(\"span\", {\n    Style: \"margin: 45px\",\n    children: /*#__PURE__*/_jsxDEV(\"line\", {\n      alignmentBaseline: true,\n      children: \"copy leftElementValue  \"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 105,\n      columnNumber: 36\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 105,\n    columnNumber: 9\n  }, this),\n  l5: /*#__PURE__*/_jsxDEV(\"span\", {\n    Style: \"margin: 35px\",\n    children: /*#__PURE__*/_jsxDEV(\"line\", {\n      children: \"else: copy rightElementValue\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 107,\n      columnNumber: 38\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 107,\n    columnNumber: 11\n  }, this),\n  l10: /*#__PURE__*/_jsxDEV(\"span\", {\n    Style: \"margin: 0px\",\n    children: /*#__PURE__*/_jsxDEV(\"line\", {\n      children: \"copy elements back to original array\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 108,\n      columnNumber: 36\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 108,\n    columnNumber: 10\n  }, this),\n  l7: /*#__PURE__*/_jsxDEV(\"span\", {\n    Style: \"margin: 15px\",\n    children: /*#__PURE__*/_jsxDEV(\"line\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 109,\n      columnNumber: 35\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 109,\n    columnNumber: 8\n  }, this),\n  l8: /*#__PURE__*/_jsxDEV(\"span\", {\n    Style: \"margin: 0px\",\n    children: /*#__PURE__*/_jsxDEV(\"line\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 110,\n      columnNumber: 34\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 110,\n    columnNumber: 8\n  }, this),\n  l9: /*#__PURE__*/_jsxDEV(\"span\", {\n    Style: \"margin: 0px\",\n    children: /*#__PURE__*/_jsxDEV(\"line\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 111,\n      columnNumber: 34\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 111,\n    columnNumber: 8\n  }, this)\n  /*  description: (\n     <p>\n     <div className=\"card post\" Style=\"text-align:left\" > \n           <div id=\"screen\" Style=\"margin: 15px\">\n           split each element into partitions of size 1<br/> \n                 <span id=\"swapped\" Style=\"margin-left:20px\">\n                <br/>recursively merge adjacent partitions <br/>\n                   </span><br/>\n             <span id=\"change\" Style=\"margin-left:40px\" >\n             for i = leftelementId to rightelementId<br/>\n             </span><br/>\n             <span id=\"compare\" className=\"Bar_stateA\" Style=\"margin-left:60px\">\n             {\"if leftPartHeadValue <= rightPartHeadValue\"}<br/>\n             </span><br/>\n             <span id=\"swap\" Style=\"margin-left:80px\">\n             copy leftElementValue\n  else: copy rightElementValue\n  <br/> </span><br/>\n             <span id=\"swap\"  Style=\"margin-left:80px\">\n             else: copy rightElementValue<br/>\n             </span><br/>\n             <span id=\"change\">copy elements back to original array</span>\n           </div></div>\n          \n     </p>\n   ),\n   */\n\n};\nexport const MergeSortDesc = {\n  title: 'Merge Sort',\n  description: /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"p\", {\n      children: [/*#__PURE__*/_jsxDEV(\"a\", {\n        href: \"https://en.wikipedia.org/wiki/Merge_sort\",\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        children: \"Merge Sort\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 147,\n        columnNumber: 9\n      }, this), ' ', \"is an efficient, stable sorting algorith that makes use of the divide and conquer strategy. Conceptually the algorithm works as follows:\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 146,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"ol\", {\n      children: [/*#__PURE__*/_jsxDEV(\"li\", {\n        children: [\"Divide the unsorted list into \", /*#__PURE__*/_jsxDEV(\"em\", {\n          children: \"n\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 160,\n          columnNumber: 41\n        }, this), \" sublists, each containing one element(a list of one element is considered sorted)\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 159,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n        children: \"Repeatedly merge sublists to produce new sorted sublists until there is only one sublist remaining. This will be the sorted list.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 164,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 158,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 145,\n    columnNumber: 5\n  }, this),\n  worstCase: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 174,\n      columnNumber: 9\n    }, this), \" log \", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 174,\n      columnNumber: 24\n    }, this), \")\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 173,\n    columnNumber: 5\n  }, this),\n  avgCase: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 179,\n      columnNumber: 9\n    }, this), \" log \", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 179,\n      columnNumber: 24\n    }, this), \")\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 178,\n    columnNumber: 5\n  }, this),\n  bestCase: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 184,\n      columnNumber: 9\n    }, this), \" log \", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 184,\n      columnNumber: 24\n    }, this), \")\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 183,\n    columnNumber: 5\n  }, this),\n  space: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 189,\n      columnNumber: 9\n    }, this), \")\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 188,\n    columnNumber: 5\n  }, this)\n};\nexport default MergeSort;\n\nvar _c;\n\n$RefreshReg$(_c, \"MergeSort\");","map":{"version":3,"sources":["D:/CSE499B/visualize-algo/src/components/algorithms/MergeSort.js"],"names":["React","newTrace","addToTrace","createKey","MergeSort","nums","trace","merge","original","start","mid","end","left","slice","right","i","j","k","length","recursiveMergeSort","midPoint","Math","floor","Array","keys","map","MergeSortKey","MergeSortP","l0","l1","l2","l3","l4","l5","l10","l7","l8","l9","MergeSortDesc","title","description","worstCase","avgCase","bestCase","space"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { newTrace, addToTrace, createKey } from './helpers';\n\nconst MergeSort = (nums) => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function merge(original, start, mid, end) {\n    const left = original.slice(start, mid);\n    const right = original.slice(mid, end);\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    while (i < left.length && j < right.length) {\n      if (left[i] <= right[j]) {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = left[i];\n        i++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      } else {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = right[j];\n        j++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      }\n      k++;\n    }\n    while (i < left.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = left[i];\n      i++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n    while (j < right.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = right[j];\n      j++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    left.length = 0;\n    right.length = 0;\n  }\n\n  function recursiveMergeSort(original, start, end) {\n    const length = end - start;\n    if (length < 2) {\n      // original = []\n      if (length < 1) return original;\n      // original = [x]\n      else return [original[start]];\n    }\n\n    const midPoint = Math.floor((start + end) / 2);\n\n    // Visualize: First Half\n    addToTrace(\n      trace,\n      original,\n      [],\n      [...Array(midPoint - start).keys()].map((i) => i + start)\n    );\n    recursiveMergeSort(original, start, midPoint);\n\n    // Visualize: Second Half\n    addToTrace(\n      trace,\n      original,\n      [],\n      [...Array(end - midPoint).keys()].map((i) => i + midPoint)\n    );\n    recursiveMergeSort(original, midPoint, end);\n\n    merge(original, start, midPoint, end);\n  }\n\n  recursiveMergeSort(nums, 0, nums.length);\n\n  // Visualize: Mark all elements as sorted\n  addToTrace(trace, nums, [...Array(nums.length).keys()]);\n  return trace;\n};\n\nexport const MergeSortKey = createKey(\n  'Call Merge Sort',\n  null,\n  'Overwrite from axillary array'\n);\n\nexport const MergeSortP= {\n\n\n    l0:(<span Style=\"margin: 0px\"><line> split each element into partitions of size 1</line></span>),\n  \n    l1: (<span Style=\"margin: 15px\"><line>recursively merge adjacent partitions </line></span>),\n    l2:(<span Style=\"margin: 25px\">\n    <line >  for i = leftelementId to rightelementId <br/></line></span>\n    ),\n    l3:(<span Style=\"margin: 35px\"><line >\n    {\"if leftPartHeadValue <= rightPartHeadValue\"}\n  </line></span>\n  ),\n    l4:(<span Style=\"margin: 45px\"><line alignmentBaseline>\n       copy leftElementValue  </line></span>),\n      l5:(<span Style=\"margin: 35px\"><line>else: copy rightElementValue</line></span>),\n    l10:(<span Style=\"margin: 0px\"><line>copy elements back to original array</line></span>),\n   l7:(<span Style=\"margin: 15px\"><line></line></span>),\n   l8:(<span Style=\"margin: 0px\"><line></line></span>),\n   l9:(<span Style=\"margin: 0px\"><line></line></span>),\n   \n /*  description: (\n    <p>\n    <div className=\"card post\" Style=\"text-align:left\" > \n          <div id=\"screen\" Style=\"margin: 15px\">\n          split each element into partitions of size 1<br/> \n                <span id=\"swapped\" Style=\"margin-left:20px\">\n               <br/>recursively merge adjacent partitions <br/>\n                  </span><br/>\n            <span id=\"change\" Style=\"margin-left:40px\" >\n            for i = leftelementId to rightelementId<br/>\n            </span><br/>\n            <span id=\"compare\" className=\"Bar_stateA\" Style=\"margin-left:60px\">\n            {\"if leftPartHeadValue <= rightPartHeadValue\"}<br/>\n            </span><br/>\n            <span id=\"swap\" Style=\"margin-left:80px\">\n            copy leftElementValue\nelse: copy rightElementValue\n<br/> </span><br/>\n            <span id=\"swap\"  Style=\"margin-left:80px\">\n            else: copy rightElementValue<br/>\n            </span><br/>\n            <span id=\"change\">copy elements back to original array</span>\n          </div></div>\n         \n    </p>\n  ),\n  */\n};\n\nexport const MergeSortDesc = {\n  title: 'Merge Sort',\n  description: (\n    <div>\n      <p>\n        <a\n          href=\"https://en.wikipedia.org/wiki/Merge_sort\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Merge Sort\n        </a>{' '}\n        is an efficient, stable sorting algorith that makes use of the\n        divide and conquer strategy. Conceptually the algorithm works as\n        follows:\n      </p>\n      <ol>\n        <li>\n          Divide the unsorted list into <em>n</em> sublists, each\n          containing one element(a list of one element is considered\n          sorted)\n        </li>\n        <li>\n          Repeatedly merge sublists to produce new sorted sublists until\n          there is only one sublist remaining. This will be the sorted\n          list.\n        </li>\n      </ol>\n    </div>\n  ),\n  worstCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  avgCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  bestCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  space: (\n    <span>\n      O(<em>n</em>)\n    </span>\n  )\n};\nexport default MergeSort;\n"]},"metadata":{},"sourceType":"module"}
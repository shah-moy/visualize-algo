{"ast":null,"code":"var _jsxFileName = \"D:\\\\CSE499A\\\\al-khwarizmi\\\\src\\\\components\\\\algorithms\\\\QuickSort3.js\";\nimport React from 'react';\nimport { swap, newTrace, addToTrace, lastSorted, createRange, createKey } from './helpers';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst QuickSort3 = nums => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function choosePivot(array, start, end) {\n    // randomly pick an element between start and end;\n    return Math.floor(Math.random() * (end - start)) + start;\n  }\n\n  function partition(array, start, end) {\n    const pivot = array[start];\n    let i = start + 1;\n    let j = start + 1;\n    let k = start + 1; // Between k and end : uncheked\n    // Between start and i : equal to pivot\n    // Between i and j : less than pivot\n    // Between j and k : greater than pivot\n    // Visualize: Keep pivot marked\n\n    addToTrace(trace, array, lastSorted(trace), [start]);\n\n    while (k < end) {\n      if (array[k] === pivot) {\n        // Visualize: Mark item that is equal to pivot\n        addToTrace(trace, array, lastSorted(trace), [start, ...createRange(start, i)], [k], [], createRange(i, j));\n        swap(array, i, k); // Visualize: Mark item that is equal to pivot\n\n        addToTrace(trace, array, lastSorted(trace), [start, ...createRange(start, i)], [i], [], createRange(i, j));\n        if (j > i) swap(array, j, k);\n        i += 1;\n        j += 1;\n      } else if (array[k] < pivot) {\n        // Visualize: Mark item that is less than pivot\n        addToTrace(trace, array, lastSorted(trace), [start, ...createRange(start, i)], [k], [], createRange(i, j));\n        swap(array, j, k); // Visualize: Move item to lesser list\n\n        addToTrace(trace, array, lastSorted(trace), [start, ...createRange(start, i)], [j], [], createRange(i, j));\n        j += 1;\n      }\n\n      k += 1;\n    }\n\n    const pivot_elements = i - start;\n    i -= 1;\n    j -= 1;\n\n    while (i >= start) {\n      swap(array, i, j);\n      i -= 1;\n      j -= 1;\n    } // Visualize: Move pivot_elements to center\n\n\n    addToTrace(trace, array, lastSorted(trace), createRange(j + 1, j + 1 + pivot_elements), [], [], createRange(start, j + 1));\n    return [j + 1, j + 1 + pivot_elements];\n  }\n\n  function recursiveQuickSort3(array, start, end) {\n    if (start >= end - 1) {\n      if (start === end - 1) {\n        // Visualize: Mark only item as sorted\n        addToTrace(trace, array, [...lastSorted(trace), start]);\n      }\n\n      return null;\n    }\n\n    let pivot = choosePivot(array, start, end); // Visualize: Mark chosen pivot\n\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n    swap(array, start, pivot); // Visualize: Move chosen pivot to start\n\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n    let [pivotStart, pivotEnd] = partition(array, start, end); // Visualize: Mark pivot after partition as sorted\n\n    addToTrace(trace, array, [...lastSorted(trace), ...createRange(pivotStart, pivotEnd)]);\n    recursiveQuickSort3(array, start, pivotStart);\n    recursiveQuickSort3(array, pivotEnd, end);\n  }\n\n  recursiveQuickSort3(nums, 0, nums.length);\n  return trace;\n};\n\n_c = QuickSort3;\nexport const QuickSort3Key = createKey('Comparing', 'Swapping', null, 'Less than pivot');\nexport const QuickSort3Desc = {\n  title: 'Quick Sort 3-Way Partitioning',\n  description: /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [/*#__PURE__*/_jsxDEV(\"a\", {\n        href: \"https://en.wikipedia.org/wiki/Quicksort#Repeated_elements\",\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        children: \"Quick Sort\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 162,\n        columnNumber: 9\n      }, this), ' ', \"exhibits poor performance on arrays that contain many repeated elements. This issue (\", /*#__PURE__*/_jsxDEV(\"a\", {\n        href: \"https://en.wikipedia.org/wiki/Dutch_national_flag_problem\",\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        children: \"Dutch national flag problem\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 171,\n        columnNumber: 9\n      }, this), \") can be solved by using an alternative linear-time partitioning routine that separates the values into three groups: values less than the pivot, values equal to the pivot, and values greater than the pivot. The values equal to the pivot are already sorted, so only the less-than and greater-than partitions need to be recursively sorted.\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 161,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 160,\n    columnNumber: 5\n  }, this),\n  worstCase: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 189,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"sup\", {\n      children: \"2\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 190,\n      columnNumber: 7\n    }, this), \")\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 188,\n    columnNumber: 5\n  }, this),\n  avgCase: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 195,\n      columnNumber: 9\n    }, this), \" log \", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 195,\n      columnNumber: 24\n    }, this), \")\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 194,\n    columnNumber: 5\n  }, this),\n  bestCase: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 200,\n      columnNumber: 9\n    }, this), \")\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 199,\n    columnNumber: 5\n  }, this),\n  space: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(log \", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 205,\n      columnNumber: 13\n    }, this), \")\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 204,\n    columnNumber: 5\n  }, this)\n};\nexport default QuickSort3;\n\nvar _c;\n\n$RefreshReg$(_c, \"QuickSort3\");","map":{"version":3,"sources":["D:/CSE499A/al-khwarizmi/src/components/algorithms/QuickSort3.js"],"names":["React","swap","newTrace","addToTrace","lastSorted","createRange","createKey","QuickSort3","nums","trace","choosePivot","array","start","end","Math","floor","random","partition","pivot","i","j","k","pivot_elements","recursiveQuickSort3","pivotStart","pivotEnd","length","QuickSort3Key","QuickSort3Desc","title","description","worstCase","avgCase","bestCase","space"],"mappings":"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","sourcesContent":["import React from 'react';\nimport {\n  swap,\n  newTrace,\n  addToTrace,\n  lastSorted,\n  createRange,\n  createKey\n} from './helpers';\n\nconst QuickSort3 = (nums) => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function choosePivot(array, start, end) {\n    // randomly pick an element between start and end;\n    return Math.floor(Math.random() * (end - start)) + start;\n  }\n\n  function partition(array, start, end) {\n    const pivot = array[start];\n    let i = start + 1;\n    let j = start + 1;\n    let k = start + 1;\n    // Between k and end : uncheked\n    // Between start and i : equal to pivot\n    // Between i and j : less than pivot\n    // Between j and k : greater than pivot\n\n    // Visualize: Keep pivot marked\n    addToTrace(trace, array, lastSorted(trace), [start]);\n\n    while (k < end) {\n      if (array[k] === pivot) {\n        // Visualize: Mark item that is equal to pivot\n        addToTrace(\n          trace,\n          array,\n          lastSorted(trace),\n          [start, ...createRange(start, i)],\n          [k],\n          [],\n          createRange(i, j)\n        );\n\n        swap(array, i, k);\n\n        // Visualize: Mark item that is equal to pivot\n        addToTrace(\n          trace,\n          array,\n          lastSorted(trace),\n          [start, ...createRange(start, i)],\n          [i],\n          [],\n          createRange(i, j)\n        );\n\n        if (j > i) swap(array, j, k);\n        i += 1;\n        j += 1;\n      } else if (array[k] < pivot) {\n        // Visualize: Mark item that is less than pivot\n        addToTrace(\n          trace,\n          array,\n          lastSorted(trace),\n          [start, ...createRange(start, i)],\n          [k],\n          [],\n          createRange(i, j)\n        );\n\n        swap(array, j, k);\n\n        // Visualize: Move item to lesser list\n        addToTrace(\n          trace,\n          array,\n          lastSorted(trace),\n          [start, ...createRange(start, i)],\n          [j],\n          [],\n          createRange(i, j)\n        );\n\n        j += 1;\n      }\n      k += 1;\n    }\n\n    const pivot_elements = i - start;\n    i -= 1;\n    j -= 1;\n    while (i >= start) {\n      swap(array, i, j);\n      i -= 1;\n      j -= 1;\n    }\n\n    // Visualize: Move pivot_elements to center\n    addToTrace(\n      trace,\n      array,\n      lastSorted(trace),\n      createRange(j + 1, j + 1 + pivot_elements),\n      [],\n      [],\n      createRange(start, j + 1)\n    );\n    return [j + 1, j + 1 + pivot_elements];\n  }\n\n  function recursiveQuickSort3(array, start, end) {\n    if (start >= end - 1) {\n      if (start === end - 1) {\n        // Visualize: Mark only item as sorted\n        addToTrace(trace, array, [...lastSorted(trace), start]);\n      }\n      return null;\n    }\n\n    let pivot = choosePivot(array, start, end);\n\n    // Visualize: Mark chosen pivot\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n\n    swap(array, start, pivot);\n\n    // Visualize: Move chosen pivot to start\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n\n    let [pivotStart, pivotEnd] = partition(array, start, end);\n\n    // Visualize: Mark pivot after partition as sorted\n    addToTrace(trace, array, [\n      ...lastSorted(trace),\n      ...createRange(pivotStart, pivotEnd)\n    ]);\n\n    recursiveQuickSort3(array, start, pivotStart);\n    recursiveQuickSort3(array, pivotEnd, end);\n  }\n\n  recursiveQuickSort3(nums, 0, nums.length);\n\n  return trace;\n};\n\nexport const QuickSort3Key = createKey(\n  'Comparing',\n  'Swapping',\n  null,\n  'Less than pivot'\n);\n\nexport const QuickSort3Desc = {\n  title: 'Quick Sort 3-Way Partitioning',\n  description: (\n    <div>\n      <p>\n        <a\n          href=\"https://en.wikipedia.org/wiki/Quicksort#Repeated_elements\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Quick Sort\n        </a>{' '}\n        exhibits poor performance on arrays that contain many repeated\n        elements. This issue (\n        <a\n          href=\"https://en.wikipedia.org/wiki/Dutch_national_flag_problem\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Dutch national flag problem\n        </a>\n        ) can be solved by using an alternative linear-time partitioning\n        routine that separates the values into three groups: values less\n        than the pivot, values equal to the pivot, and values greater\n        than the pivot. The values equal to the pivot are already\n        sorted, so only the less-than and greater-than partitions need\n        to be recursively sorted.\n      </p>\n    </div>\n  ),\n  worstCase: (\n    <span>\n      O(<em>n</em>\n      <sup>2</sup>)\n    </span>\n  ),\n  avgCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  bestCase: (\n    <span>\n      O(<em>n</em>)\n    </span>\n  ),\n  space: (\n    <span>\n      O(log <em>n</em>)\n    </span>\n  )\n};\n\nexport default QuickSort3;\n"]},"metadata":{},"sourceType":"module"}